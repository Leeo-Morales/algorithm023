<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/602809 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1112"/>

<div>
<span><div><div><div><div><div><div><div><div><div><font style="font-size: 36pt;"><span style="font-size: 36pt; color: rgb(255, 175, 0); font-weight: bold;">Summary of points</span></font></div><div><br/></div><div><span style="font-size: 24pt; color: rgb(30, 204, 255); font-weight: bold;">如何高效学习算法</span></div><hr/><ul><li><div><span style="font-size: 16pt; font-weight: bold;">git / github 操作指南</span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">三分看视频理解、七分练习 --- 1.5~2.0倍速播放、难点（暂停 + 反复）</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><span style="font-size: 16pt; font-weight: bold; color: rgb(65, 173, 28);">不要死磕</span>（传统方式）</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">五毒神掌（</span><span style="font-size: 16pt; color: rgb(65, 173, 28); font-weight: bold;">敢于放手、敢于死记硬背代码、重要的是过遍数</span><span style="font-size: 16pt; font-weight: bold;">）</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">不懒于看高手代码（国际版的高票回答）</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(65, 173, 28); font-weight: bold;">最大的误区：LeetCode题目只做一遍！</span></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">精通一个领域：切碎知识点 - 刻意练习 - 反馈</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(65, 173, 28); font-weight: bold;">切题四件套：Clarification, Possible solutions(optimal through time/space), Coding, Test cases</span></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image.png" type="image/png" data-filename="Image.png" title="Attachment"/></span></span></div></li></ul><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"></col><col style="width: 130px;"></col><col style="width: 289px;"></col></colgroup><tbody><tr><td colspan="3" style="vertical-align: middle; background-color: rgb(66, 107, 179); border: 1px solid rgb(53, 86, 143); width: 549px; padding: 8px;"><div style="text-align: center;"><font style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(255, 255, 255); font-weight: bold;">五毒神掌</span></font></div></td></tr><tr><td rowspan="3" style="height: 92px; background-color: rgb(251, 207, 214); border: 1px solid rgb(244, 122, 142); width: 130px; padding: 8px;"><div style="text-align: center;"><br/></div><div style="text-align: center;"><br/></div><div style="text-align: center;"><span style="font-size: unset; font-family: unset;">刷题第一遍</span></div></td><td colspan="2" style="background-color: rgb(251, 207, 214); border: 1px solid rgb(244, 122, 142); width: 419px; padding: 8px;"><div><span style="font-size: 10pt;">5分钟：读题+思考</span></div></td></tr><tr><td colspan="2" style="background-color: rgb(251, 207, 214); border: 1px solid rgb(244, 122, 142); width: 419px; padding: 8px;"><div><span style="font-size: 10pt;">直接看题解：注意！多解法、比较解法优劣</span></div></td></tr><tr><td colspan="2" style="background-color: rgb(251, 207, 214); border: 1px solid rgb(244, 122, 142); width: 419px; padding: 8px;"><div><span style="font-size: 10pt;">背诵、默写好的解法</span></div></td></tr><tr><td rowspan="2" style="height: 56px; vertical-align: middle; background-color: rgb(254, 222, 193); border: 1px solid rgb(253, 175, 105); width: 130px; padding: 8px;"><div style="text-align: center;">刷题第二遍</div></td><td colspan="2" style="background-color: rgb(254, 222, 193); border: 1px solid rgb(253, 175, 105); width: 419px; padding: 8px;"><div><span style="font-size: 10pt;">马上自己写 - LeetCode提交</span></div></td></tr><tr><td colspan="2" style="background-color: rgb(254, 222, 193); border: 1px solid rgb(253, 175, 105); width: 419px; padding: 8px;"><div>多种解法比较、体会 - 优化！</div></td></tr><tr><td style="background-color: rgb(255, 230, 151); border: 1px solid rgb(255, 211, 70); width: 130px; padding: 8px;"><div style="text-align: center;"><span style="font-size: 10pt;">刷题第三遍</span></div></td><td colspan="2" style="background-color: rgb(255, 230, 151); border: 1px solid rgb(255, 211, 70); width: 419px; padding: 8px;"><div><span style="font-size: 10pt;">过了一天之后，再重复做题，不同解法的熟练程度 - 专项练习</span></div></td></tr><tr><td style="text-align: center; background-color: rgb(205, 238, 240); border: 1px solid rgb(137, 215, 220); width: 130px; padding: 8px;">刷题第四遍</td><td colspan="2" style="background-color: rgb(205, 238, 240); border: 1px solid rgb(137, 215, 220); width: 419px; padding: 8px;"><div><span style="font-size: 10pt;">过了一周：反复回来练习相同题目</span></div></td></tr><tr><td style="text-align: center; background-color: rgb(205, 230, 249); border: 1px solid rgb(124, 190, 239); width: 130px; padding: 8px;"><span style="font-size: 10pt;">刷题第五遍</span></td><td colspan="2" style="background-color: rgb(205, 230, 249); border: 1px solid rgb(124, 190, 239); width: 419px; padding: 8px;"><div>过了两周：反复回来练习相同题目</div></td></tr></tbody></table><div><br/></div></div><div><br/></div></div><div><font style="font-size: 24pt;"><span style="font-size: 24pt; color: rgb(30, 204, 255); font-weight: bold;">数组、链表、跳表、栈、队列、优先队列、双端队列</span></font></div><hr/><ul><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">数组、链表、跳表的原理和实现</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">三者的时间复杂度、空间复杂度</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(222, 87, 0); font-weight: bold;">跳表：升维思想 + 空间换时间</span></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">Stack、Queue、Deque 的原理和操作复杂度</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">PriorityQueue 的特点和操作复杂度</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">查询 Stack、Queue、Deque、PriorityQueue 的系统接口的方法</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [1].png" type="image/png" data-filename="Image.png" title="Attachment"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [2].png" type="image/png" data-filename="Image.png" title="Attachment"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [3].png" type="image/png" data-filename="Image.png" title="Attachment"/></span></span></div></li></ul><div><span style="font-size: 16pt;"><br/></span></div><div><span style="font-size: 24pt; color: rgb(30, 204, 255); font-weight: bold;">哈希表，映射，集合，树，二叉树，二叉搜索树，堆，二叉堆，图</span></div><hr/><ul><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">哈希表（Hash table），也叫散列表，是根据关键码值（Key value）而直接进行访问的数据结构</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">哈希表通过关键码值映射到表中一个位置来访问记录，以加快查找的速度</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(65, 173, 28); font-weight: bold;">Linked List 是特殊化的 Tree, Tree 是特殊化的 Graph</span></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">二叉树的遍历 Pre-order/In-order/Post-order</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(156, 0, 76); font-weight: bold;">Pre-order --- root - left - right</span></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(156, 0, 76); font-weight: bold;">In-order --- left - root - right</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(156, 0, 76); font-weight: bold;">Post-order --- left - right - root</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">二叉搜索树（Binary Search Tree），也称二叉排序树，是指一棵空树或者具有下列性质的二叉树：1. 左子树上</span><span style="font-size: 16pt; color: rgb(255, 0, 0); font-weight: bold;">所有结点</span><span style="font-size: 16pt; font-weight: bold;">的值均小于它的根节点的值；2. 右子树上</span><span style="font-size: 16pt; color: rgb(255, 0, 0); font-weight: bold;">所有结点</span><span style="font-size: 16pt; font-weight: bold;">的大小均大于它的根节点的值；3. 以此类推：</span><span style="font-size: 16pt; color: rgb(65, 173, 28); font-weight: bold;">左、右子树分别为二叉查找树</span><span style="font-size: 16pt; font-weight: bold;">。（这就是</span> <span style="font-size: 16pt; color: rgb(134, 0, 164); font-weight: bold;">重复性！</span><span style="font-size: 16pt; font-weight: bold;">）</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(222, 87, 0); font-weight: bold;">二查搜索树的中序遍历：升序排列</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">堆（Heap）和 二叉堆（Binary Heap），Heap：可以迅速找到一堆数中的最大或者最小的数据结构（根节点最大的堆叫做大顶堆或大根堆，根节点最小的叫做小顶堆或小根堆），常见的有二叉堆、斐波那契堆</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(65, 173, 28); font-weight: bold;">二叉堆的性质，通过完全二叉树来实现，1. 一个完全二叉树；2. 树中任意节点的值总是大于等于其子节点的值</span></span></div></li><li><div><img src="Summary of points_files/Image [4].png" type="image/png" data-filename="Image.png" style="font-size: 16pt; font-weight: bold; color: unset; font-family: unset;" title="Attachment"/></div></li><li><div><img src="Summary of points_files/Image [5].png" type="image/png" data-filename="Image.png" style="font-size: 16pt; font-weight: bold; color: unset; font-family: unset;" title="Attachment"/></div></li><li><div><img src="Summary of points_files/Image [6].png" type="image/png" data-filename="Image.png" style="color: unset; font-family: unset; font-size: 16pt; font-weight: bold;" title="Attachment"/></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">二叉堆是堆（优先队列 priority_queue）的一种常见且简单的实现；但是并不是最优的实现</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">图（Graph），Graph(V, E)；V - vertex：点 1. 度 - 入度和出度，2. 点与点之间：连通与否；E - edge：边 1. 有向和无向（单行线），2. 权重（边长）</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">图的存储：邻接矩阵，邻接表</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">图的常见算法：深度优先遍历（BFS），广度优先遍历（DFS）</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">图的高级算法：连通图个数，拓扑排序（Topological Sorting），最短路径（Shortest Path），最小生成树（Minimum Spanning Tree）</span></span></div></li></ul><div><br/></div><div><br/></div><div><span style="font-size: 24pt; color: rgb(30, 204, 255); font-weight: bold;">泛型递归，树的递归，分治，回溯</span></div><hr/><ul><li><div><font style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(255, 0, 0); font-weight: bold;">有关树的算法题解一般都是递归，取决于1. 节点的定义；2. 重复性（自相似性）</span></font></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(65, 173, 28); font-weight: bold;">递归的时间复杂度一般均为O(k^n)</span><span style="font-size: 16pt; color: rgb(168, 168, 168); font-weight: bold;">【取决于其对应的二叉树有几个分支】</span><span style="font-size: 16pt; color: rgb(255, 0, 0); font-weight: bold;">，</span><span style="font-size: 16pt; color: rgb(65, 173, 28); font-weight: bold;">若只有一个分支，则为O(n)</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; color: unset; font-family: unset; font-weight: bold;">递归（Recursion），归去来兮的感觉！</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [7].png" type="image/png" data-filename="Image.png" title="点击下载"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">递归（Recursion）的思维要点：</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [8].png" type="image/png" data-filename="Image.png" title="Attachment"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">分治（Divide &amp; Conquer）</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [9].png" type="image/png" data-filename="Image.png" title="Attachment"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><span style="font-size: 16pt; font-weight: bold; color: rgb(65, 173, 28);">回溯（Backtracking），回溯法采用试错的思想</span>，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">回溯法通常用最简单的递归方法来实现，在反复重复上述步骤后可能出现两种情况：</span><span style="font-size: 16pt; color: rgb(222, 87, 0); font-weight: bold;">1. 找到一个可能存在的正确的答案；2. 在尝试了所有可能的分步方法后宣告该问题没有答案</span><span style="font-size: 16pt; font-weight: bold;">。</span></span></div></li></ul><div><br/></div><div><br/></div><div><font style="font-size: 24pt;"><span style="font-size: 24pt; color: rgb(30, 204, 255); font-weight: bold;">深度优先搜索和广度优先搜索、贪心算法、二分查找</span></font></div></div><hr/><ul><li><div><font style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(167, 69, 0); font-weight: bold;">搜索 - 遍历、每个节点都要访问且仅访问一次，而对于节点的访问顺序不限 - 深度优先（depth first search）、广度优先（breadth first search）</span></font></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">深度优先搜索（Depth-First-Search）的递归写法</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">深度优先搜索（Depth-First-Search）的遍历顺序</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [10].png" type="image/png" data-filename="Image.png" title="点击下载"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">广度优先搜索（Breadh-First-Search）的遍历顺序</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [11].png" type="image/png" data-filename="Image.png" title="点击下载"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(28, 51, 135); font-weight: bold;">贪心算法（Greed），贪心算法是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是全局最好或最优的算法</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(173, 0, 0); font-weight: bold;">贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(134, 0, 164); font-weight: bold;">一旦一个问题可以通过贪心算法来解决，那么贪心算法一般是解决这个问题的最好办法。</span><span style="font-size: 16pt; color: rgb(198, 197, 0); font-weight: bold;">由于贪心算法的高效性以及其所求得的答案比较接近最优结果，贪心算法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">适用贪心算法的场景：简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解，这种子问题最优称为最优子结构</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">二分查找，</span><span style="font-size: 16pt; color: rgb(65, 173, 28); font-weight: bold;">二分查找的前提是：1. 目标函数单调性（单调递增或者递减）；2. 存在上下界（bounded）；3. 能够通过索引访问（index accessible）</span></span></div></li></ul><div><font style="font-size: 10pt;"><br/></font></div></div><div><font style="font-size: 10pt;"><br/></font></div><div><font style="font-size: 24pt;"><span style="font-size: 24pt; color: rgb(30, 204, 255); font-weight: bold;">动态规划</span></font></div><hr/><ul><li><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">本质：寻找重复性 —&gt; 计算机指令集</span></font></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">动态规划（Dynamic Programming）： &quot;</span><span style="font-size: 16pt; color: rgb(222, 87, 0); font-weight: bold;">Simplifying a complicated problem by breaking it down into simpler sub-problems</span><span style="font-size: 16pt; font-weight: bold;">&quot;(in a recursive manner);</span> <span style="font-size: 16pt; color: rgb(45, 79, 201); font-weight: bold;">Divide &amp; Conqure + optimal substructure（分治 + 最优子结构）</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(65, 173, 28); font-weight: bold;">动态规划 和 递归或者分治 没有根本上的区别（关键看有无最优的子结构）</span></span></span></div></li><li><div><span style="font-size: 16pt; color: rgb(65, 173, 28); font-family: unset; font-weight: bold;">共性：找重复子问题</span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(65, 173, 28); font-weight: bold;">差异性：最优子结构、中途可以淘汰次优解</span></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(227, 0, 0); font-weight: bold;">动态规划：a. define subproblems; b. define status array (one-</span></span><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(227, 0, 0); font-weight: bold;">dimensional, two-dimension, tree structure</span></span><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(227, 0, 0); font-weight: bold;">); c. recurse &amp; memorize (Recursion) OR build Dp fable bottom-up (Programming)</span></span></div></li></ul><div><span style="font-size: 16pt;"><br/></span></div><div><font style="font-size: 24pt;"><span style="font-size: 24pt; color: rgb(30, 204, 255); font-weight: bold;">字典树和并查集、高级搜索（剪枝，双向BFS，启发式搜索）、红黑树和AVL树</span></font></div></div><hr/><ul><li><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">字典树，即Trie树，又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计</span></font></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(65, 173, 28); font-weight: bold;">字典树的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高</span></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(222, 87, 0); font-weight: bold;">字典树的基本性质：1. 结点本身不存完整单词；2. 从根结点到某一结点，路径上经过的字符连接起来，为该结点对应的字符串；3. 每个结点的所有子结点代表的字符都不相同</span></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">结点的内部实现：</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [12].png" type="image/png" data-filename="Image.png"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(134, 0, 164); font-weight: bold;">字典树的核心思想：1. Trie 树的核心思想是空间换时间；2. 利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的</span></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">并查集（DisJoint Set），适用于组团、配对以及判断多个目标是否在一组等问题</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">并查集的基本操作：</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [13].png" type="image/png" data-filename="Image.png"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">并查集的初始化、查询、合并以及路径压缩：</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [14].png" type="image/png" data-filename="Image.png"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [15].png" type="image/png" data-filename="Image.png"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [16].png" type="image/png" data-filename="Image.png"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [17].png" type="image/png" data-filename="Image.png"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(45, 79, 201); font-weight: bold;">剪枝：在遍历过程</span></span><span style="font-size: 16pt; color: rgb(45, 79, 201); font-weight: bold;">（回溯、DFS）</span><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(45, 79, 201); font-weight: bold;">中，通过相应的规约直接跳过或剔除没必要的遍历过程，即为剪枝</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">Two-ended BFS 示意图：</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [18].png" type="image/png" data-filename="Image.png"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(45, 79, 201); font-weight: bold;">启发式搜索：在遍历过程中，利用估价函数来提供搜索方向，从而进行一种存在优先级的搜索，即为启发式搜索</span></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">估价函数：</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [19].png" type="image/png" data-filename="Image.png"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">平衡二叉树（AVL）：</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [20].png" type="image/png" data-filename="Image.png"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">红黑树：</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [21].png" type="image/png" data-filename="Image.png"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(156, 0, 76); font-weight: bold;">红黑树的关键性质：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</span></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">AVL树于红黑树的对比：</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [22].png" type="image/png" data-filename="Image.png"/></span></span></div></li></ul><div><span style="font-size: 16pt;"><br/></span></div></div><div><span style="font-size: 24pt; color: rgb(30, 204, 255); font-weight: bold;">位运算、布隆过滤器和LRU缓存、排序算法</span></div><hr/><ul><li><div><font style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">为什么需要位运算 --- 机器里的数字表示方式和存储格式就是二进制</span></font></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">十进制与二进制的相互转换</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">位运算符：</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [23].png" type="image/png" data-filename="Image.png"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [24].png" type="image/png" data-filename="Image.png"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">XOR - 异或：</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [25].png" type="image/png" data-filename="Image.png"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">指定位置的位运算：</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [26].png" type="image/png" data-filename="Image.png"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">实战位运算要点：</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [27].png" type="image/png" data-filename="Image.png"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(50, 135, 18); font-weight: bold;">布隆过滤器（Bloom Filter）：一个很长的二进制向量和一系列随机映射函数，可以用于检索一个元素是否在一个集合中</span></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(20, 113, 145); font-weight: bold;">布隆过滤器的优点是空间效率和查询时间都远远超过一般的算法</span></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(20, 113, 145); font-weight: bold;">布隆过滤器的缺点是有一定的误识别率和删除困难</span></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">布隆过滤器示意图：</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [28].png" type="image/png" data-filename="Image.png"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">LRU Cache：记忆、钱包 - 储物柜</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">LRU Cache：两个要素：大小、替换策略；Hash Table + Double LinkedList；O(1)查询、O(1)修改、更新</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [29].png" type="image/png" data-filename="Image.png"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">LRU Cache 工作示例：</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [30].png" type="image/png" data-filename="Image.png"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">替换策略：LFU - least frequently used，LRU - least recently used</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(28, 51, 135); font-weight: bold;">排序算法：1. 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序；2. 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序</span></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [31].png" type="image/png" data-filename="Image.png"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">排序算法的时间、空间复杂度及稳定性：</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [32].png" type="image/png" data-filename="Image.png"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">初级排序 - O(n^2)：<span style="font-size: 16pt; font-weight: bold; color: rgb(222, 87, 0);">1. 选择排序（Selection Sort）- 每次找最小值，然后放到待排序数组的起始位置；</span><span style="font-size: 16pt; font-weight: bold; color: rgb(123, 0, 61);">2. 插入排序（Insertion Sort） - 从前到后逐步构建有序序列；对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入；</span><span style="font-size: 16pt; font-weight: bold; color: rgb(147, 150, 0);">3. 冒泡排序（Bubble Sort） - 嵌套循环，每次查看相邻元素，如果逆序则交换</span></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">高级排序 - O(nlogn)：<span style="font-size: 16pt; font-weight: bold; color: rgb(65, 173, 28);">1. 快速排序（Quick Sort）- 数组取标杆 pivot，将小元素放置于 pivot 左边，大元素放置于其右侧，然后依次对左边和右边的子数组继续快排，以达整个序列有序；</span><span style="font-size: 16pt; font-weight: bold; color: rgb(209, 0, 255);">2. 归并排序（Merge Sort）- 把长度为 n 的输入序列分为两个长度为 n/2 的子序列，对这两个子序列分别采用归并排序，将两个排序好的子序列合并成一个最终的排序序列；</span><span style="font-size: 16pt; font-weight: bold; color: rgb(65, 0, 125);">3. 堆排序（Heap Sort） - 堆插入O(logn),取最大/小值O(1) - 数组元素依次建立小顶堆，依次取堆顶元素，并删除</span></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(255, 0, 0); font-weight: bold;">归并和快排具有相似性，但步骤顺序相反：归并 - 先排序左右子数组，然后合并两个有序子数组；快排 - 先调配出左右子数组，然后对左右子数组进行排序</span></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">特殊排序 - O(n)：<span style="font-size: 16pt; font-weight: bold; color: rgb(45, 79, 201);">1. 计数排序（Counting Sort） - 计数排序要求输入的数据必须是有确定范围的整数。将输入的数据值转换为键存储在额外开辟的数组空间中，然后依次把计数大于1的填充回原数组；</span><span style="font-size: 16pt; font-weight: bold; color: rgb(134, 0, 164);">2. 桶排序（Bucket Sort） - 假设输入数据服从均匀分步，将数组分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）；</span><span style="font-size: 16pt; font-weight: bold; color: rgb(222, 87, 0);">3. 基数排序（Radix Sort） - 基数排序是按照低位先排序，然后收集，再按照高位排序，然后再收集，依此类推，直到最高位，有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序</span></span></span></div></li></ul><div><span style="font-size: 16pt;"><br/></span></div><div><span style="font-size: 24pt; color: rgb(30, 204, 255); font-weight: bold;">高级动态规划、字符串算法</span></div></div><hr/><ul><li><div><font style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(26, 144, 185); font-weight: bold;">（高级）动态规划补充 - 复杂度来源：1. 状态拥有更多维度（二维、三维、或者更多、甚至需要压缩）；2. 状态方程更加复杂</span></font></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">字符串、遍历字符串、字符串比较</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">字符串匹配：1. 暴力法（Brute force）O(mn)；2. Rabin - Karp 算法；3. KMP 算法</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">Rabin - Karp 算法：</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [33].png" type="image/png" data-filename="Image.png"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [34].png" type="image/png" data-filename="Image.png"/></span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;">KMP 算法：</span></span></div></li><li><div><span style="font-size: 16pt;"><span style="font-size: 16pt; font-weight: bold;"><img src="Summary of points_files/Image [35].png" type="image/png" data-filename="Image.png"/></span></span></div></li></ul><div><br/></div></div><hr/><div><br/></div></div></span>
</div></body></html> 